name: Deploy (dev)

on:
  push:
    branches: ["dev"]

concurrency:
  group: deploy-dev
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          port: ${{ secrets.SSH_PORT }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          debug: true
          script: |
            set -euo pipefail

            cd "${{ secrets.DEPLOY_PATH }}"

            # 1) Zatrzymanie kontenerów, aby zwolnić blokady plików
            docker compose down || true

            # 2) SIŁOWA NAPRAWA UPRAWNIEŃ (Kluczowe dla Git Reset)
            # Docker tworzy pliki jako root/www-data, których user 'ubuntu' nie może usunąć.
            # Używamy sudo, aby przejąć kontrolę i wyczyścić problematyczne miejsca.
            echo "Cleaning up storage and cache to avoid Git conflicts..."
            sudo chown -R ubuntu:ubuntu .
            sudo chmod -R u+rwX .
            
            # Usuwamy tylko zawartość runtime, aby git reset nie miał przeszkód
            rm -rf backend/storage/framework/views/* || true
            rm -rf backend/storage/logs/* || true
            rm -rf backend/bootstrap/cache/*.php || true

            # 3) Aktualizacja kodu z Git
            git fetch origin
            git reset --hard origin/dev
            git clean -fd

            # 4) Zapewnienie struktury katalogów i uprawnień 777 dla Docker
            # Musimy dać 777 tymczasowo, aby kontenery mogły tam swobodnie pisać na starcie
            mkdir -p backend/storage/framework/{cache,data,sessions,views} backend/storage/logs backend/bootstrap/cache
            sudo chmod -R 777 backend/storage backend/bootstrap/cache

            # 5) Pliki .env
            if [ ! -f .env.docker ]; then
              if [ -f backend/env.docker.example ]; then
                cp -f backend/env.docker.example .env.docker
              elif [ -f backend/.env.docker ]; then
                cp -f backend/.env.docker .env.docker
              fi
            fi

            if [ ! -f backend/.env ]; then
              if [ -f backend/.env.docker ]; then
                cp -f backend/.env.docker backend/.env
              elif [ -f backend/.env.example ]; then
                cp -f backend/.env.example backend/.env
              fi
            fi

            # Korekta APP_KEY w .env
            sed -i 's/^APP_KEY$/APP_KEY=/' backend/.env || true
            grep -q '^APP_KEY=' backend/.env || echo 'APP_KEY=' >> backend/.env

            # 6) Budowanie i start kontenerów
            docker compose up -d --build

            # 7) NAPRAWA UPRAWNIEŃ WEWNĄTRZ KONTENERA (Fix dla laravel.log)
            # To przypisuje pliki do użytkownika, na którym działa PHP-FPM (www-data)
            echo "Assigning ownership to www-data inside containers..."
            docker compose exec -T php chown -R www-data:www-data /var/www/html/storage /var/www/html/bootstrap/cache
            docker compose exec -T php chmod -R 775 /var/www/html/storage /var/www/html/bootstrap/cache

            # 8) Instalacja zależności i generowanie klucza
            docker compose exec -T php composer install --no-dev --optimize-autoloader
            docker compose exec -T php sh -lc 'grep -q "^APP_KEY=base64:" .env || php artisan key:generate --force'

            # 9) Czyszczenie cache Laravela
            docker compose exec -T php php artisan config:cache
            docker compose exec -T php php artisan route:cache
            docker compose exec -T php php artisan view:cache

            # 10) Restart workerów, aby przeładowały kod i uprawnienia
            docker compose restart queue scheduler
            
            echo "Deploy finished successfully!"
